import os
import re

from compiler.codegen.common import get_c_type, get_stream_format
from compiler.type_checker import CheckedTrapExpression, CheckedTypeExpression

_HEADER_FILE_TEMPLATE = """
// This file is auto-generated by gen/typegen/main.py
// Do not edit this file directly.
// To regenerate, run: gen/typegen/main.py -i <input_files> -o <output_file> <root_directory>

#pragma once

#include <cstdint>

#include "absl/status/status.h"

{{#includes}}
#include "{{.}}"
{{/includes}}

namespace cyder::trap::gen {

absl::Status Dispatch(uint16_t trap, {{dependencies}});

}  // namespace cyder::trap::gen
"""

_SOURCE_FILE_TEMPLATE = """
// This file is auto-generated by gen/typegen/main.py
// Do not edit this file directly.
// To regenerate, run: gen/typegen/main.py -i <input_files> -o <output_file> <root_directory>

#include <cstddef>
#include <cstdint>

#include "absl/status/status.h"
#include "absl/strings/str_cat.h"
#include "core/logging.h"
#include "emu/trap/stack_helpers.h"
#include "gen/trap_names.h"
#include "third_party/musashi/src/m68k.h"

{{#includes}}
#include "{{.}}"
{{/includes}}

constexpr bool kVerboseLogTraps = false;

#define LOG_TRAP() LOG_IF(INFO, kVerboseLogTraps) << "TRAP "

namespace cyder::trap::gen {

absl::Status Dispatch(uint16_t trap, {{dependencies}}) {
  switch(trap) {
    {{#file}}
    // {{path}}:
    {{#traps}}
    case Trap::{{name}}: {
      {{{body}}}
    }
    {{/traps}}
    {{/file}}
    default:
      return absl::UnimplementedError(absl::StrCat(
          "Unimplemented Toolbox trap: '", GetTrapName(trap), "'"));
  }
}

}  // namespace cyder::trap::gen
"""


def snake_to_camel(snake_case: str, capitalize_first: bool):
  split = snake_case.split('_')
  if capitalize_first:
    return ''.join(word.capitalize() for word in split)
  else:
    return split[0] + ''.join(word.capitalize() for word in split[1:])


def _format_log_trap(trap: CheckedTrapExpression):
  if not trap.arguments:
    return f'LOG_TRAP() << "{trap.id}()";'
  return f'LOG_TRAP() << "{trap.id}(' + ' << " '.join(f'{snake_to_camel(arg.id, capitalize_first=False)}: " << {get_stream_format('', arg)}' for arg in trap.arguments) + ' << ")";'


def _format_toolbox_trap_body(path: str, trap: CheckedTrapExpression):
  lines = []
  for arg in trap.arguments:
    pop_func = 'PopRef' if arg.type.size > 4 or arg.type.id == 'str' else 'PopType' if arg.type.is_struct else 'Pop'
    lines.append(f'auto {arg.id} = TRY({pop_func}<{get_c_type(arg.type)}>());')

  lines.append(_format_log_trap(trap))

  object_name = os.path.splitext(os.path.basename(path))[0]
  args_list = ', '.join(arg.id for arg in trap.arguments)
  if trap.ret:
    lines.append(f'auto _result = TRY({object_name}->{trap.id}({args_list}));')
    lines.append(f'return TrapReturn<{get_c_type(trap.ret)}>(_result);')
  else:
    lines.append(f'{object_name}->{trap.id}({args_list});')
    lines.append('return absl::OkStatus();')

  return '\n'.join(lines)


class RegisterAssigner:
  def __init__(self):
    self.reset()

  def get_reg(self, type: CheckedTypeExpression):
    if type.is_ref_type:
      current_a = self.a
      self.a += 1
      return f'M68K_REG_A{current_a}'
    else:
      current_d = self.d
      self.d += 1
      return f'M68K_REG_D{current_d}'

  def reset(self):
    self.a = 0
    self.d = 0


def _format_system_trap_body(path: str, trap: CheckedTrapExpression):
  assigner = RegisterAssigner()

  lines = []
  for arg in trap.arguments:
    lines.append(
        f'auto {arg.id} = m68k_get_reg(NULL, {assigner.get_reg(arg.type)});')

  lines.append(_format_log_trap(trap))

  assigner.reset()

  object_name = os.path.splitext(os.path.basename(path))[0]
  args_list = ', '.join(arg.id for arg in trap.arguments)
  if trap.ret:
    lines.append(f'auto _result = TRY({object_name}->{trap.id}({args_list}));')
    result = 'static_cast<int32_t>(_result)' if trap.ret.is_enum else '_result'
    lines.append(f'm68k_set_reg({assigner.get_reg(trap.ret)}, {result});')
  else:
    lines.append(f'{object_name}->{trap.id}({args_list});')

  lines.append('return absl::OkStatus();')
  return '\n'.join(lines)


def write_dispatch_table(output_path, path_to_traps):
  TRAP_NAMES_PATH = os.path.join(os.path.dirname(
      os.path.realpath(__file__)), '../../../trap_names.txt')

  RE_NAME_ENTRY = re.compile(r'^(?P<trap>A[\d\w]{3}) => (?P<name>[\d\w]+)$')

  trap_is_toolbox = {}
  with open(TRAP_NAMES_PATH, 'r') as f:
    for line in f.readlines():
      # Skip blank lines
      if not line.strip():
          continue

      match = RE_NAME_ENTRY.match(line)
      if not match:
          raise ValueError(f'Invalid trap name entry: "{line.strip()}"')

      (name, trap) = (match.group('name'), match.group('trap'))
      trap_is_toolbox[name] = (int(trap, 16) >> 11) & 1

  list_of_deps = [os.path.splitext(os.path.basename(path))[0]
                  for path in path_to_traps.keys()]

  import pystache
  with open(output_path + ".h", 'w') as file:
    print('writing header file:', output_path + ".h")
    file.write(pystache.render(_HEADER_FILE_TEMPLATE, {
        'includes': [f'{include}.h' for include in path_to_traps.keys()],
        'dependencies': ', '.join(
            f'::gen::{snake_to_camel(dep, capitalize_first=True)}* {dep}'
            for dep in list_of_deps),
    }))

  with open(output_path + ".cc", 'w') as file:
    file.write(pystache.render(_SOURCE_FILE_TEMPLATE, {
        'includes': [f'{include}.h' for include in path_to_traps.keys()],
        'dependencies': ', '.join(
            f'::gen::{snake_to_camel(dep, capitalize_first=True)}* {dep}'
            for dep in list_of_deps),
        'file': [
            {
                'path': path, 'traps': [
                    {
                        'name': trap.id,
                        'body': _format_toolbox_trap_body(path, trap)
                                if trap_is_toolbox[trap.id]
                                else _format_system_trap_body(path, trap)
                    }
                    for trap in traps]
            }
            for (path, traps) in path_to_traps.items()],
    }))
